\subsection{Implementation des Mathematik-Pakets in die GUI}
Als sowohl die GUI als auch das Mathematik-Paket fertiggestellt waren, war per Benutzereingabe immer noch keine Rechnung durchführbar. Was zu diesem Zeitpunkt noch fehlte, war eine passende Implementation, die sicher stellte, dass all unsere festgelegten Strukturen in der Software auch aus Benutzereingaben übersetzt werden konnten. Da dieses Thema letzten Endes sehr viel Aufwand in Anspruch nahm, wollten wir ihm ein eigenes Kapitel widmen.\\
\\
Die zwei wichtigsten Aufgaben beim Kommunizieren zwischen Mathematik-Paket und GUI sind einerseits das Darstellen von Unterklassen von \displaycode{MathObject} und andererseits das Übersetzen in ein \displaycode{MathObject}, das wir, wie es in der Informatik üblich sein zu scheint, als \textit{Parsing} bezeichneten.

\subsubsection{Darstellen mathematischer Strukturen}
Bezüglich der Darstellung gab es in diesem Fall schon Vorgaben aus der GUI hinsichtlich des \displaycode{Sprite}-Interfaces. Jedes \displaycode{MathObject} musste von nun an, da zum Anzeigen eine Implementierung des Interfaces nötig war, sämtliche Methoden zur Darstellung beinhalten, wie zum Beispiel \displaycode{void paint(Graphics g)} eine war. An diesem Punkt wird wieder sicher, dass sich die geschachtelte Objektstruktur gelohnt hat, denn jedes \displaycode{Mathobject} kann im Grunde für seine relevante Darstellung sorgen und den ganzen Rest seinen möglichen Subobjekten überlassen. Um diese Vorgehensweise zu verdeutlichen, möchte ich hier ein Beispiel einbauen, man sieht den Programmcode für die Methode der Klasse in \displaycode{Sum}.\\

\displayimageg{img/sachsenschnitzel/code_Sum_paint_cropped}{Methode zum Zeichnen von Summen am Bildschirm}

\noindent
Anfangs führen wir einige Überprüfungen durch, die jedoch eher nebensächlich sind. Im unteren Teil erst sind die relevanten Teile vorzufinden. Es soll ganz einfach ein Summand nach dem anderen sich selbst zeichnen, an der Position wo er gerade ist (der erste wird separat gezeichnet, weil es sonst Probleme mit den '+' - Operatoren gibt). Aber woher weiß der einzelne Summand denn wo er am Bildschirm ist? Natürlich hat jeder seinen Platz im \displaycode{MathObject}, das ihn beinhaltet, das sind bloß nur Indices und keine Koordinaten, die zum Zeichnen am Bildschirm benötigt werden.\\
\\
Wenn man tiefer hinein blickt, fällt einem vielleicht auf, dass sich eigentlich \underline{zwei} Problematiken dahinter verbergen. Zum Einen ist da die der Größe. Eine Summe kann nur wissen, wie viel Platz sie benötigt, wenn ihre Subterme deren Größen bereits kennen. Und zum Anderen macht eben die Position ein Problem. Die Subterme können erst platziert werden, wenn der Über-Term seine Position am Feld kennt.\\
\\
Als Lösung für dieses Dilemma blieb uns nichts Anderes, als eine neue Methode \displaycode{void optSructure(Graphics g)} einzuführen, die sich im Falle des \displaycode{Term} in \displaycode{void optSubPos(Graphics g)} und \displaycode{void optSize(Graphics g)} aufspaltete. Der \textit{Graphics-Context}(... \displaycode{Graphics g}) wird leider in all diesen Methoden benötigt, da die aktuelle Schrift zur Berechnung notwendig ist. Die Abkürzung 'opt' soll hier einfach für ''optimize'' stehen. Werden die Methoden hintereinander aufgerufen, so kann alles einwandfrei vermessen werden und jedes \displaycode{MathObject} hat immer die richtige Größe.\\
\\
Der nächste Meilenstein bei der Darstellung war natürlich der Teil, wo tatsächlich User-Interface vermittelt werden sollte, wie zum Beispiel beim Ausrechnen. Wird eine unvollständige Gleichung eingegeben (linke Seite befüllt, rechte Seite leer) und die fehlende Seite ist errechenbar, so soll ein Auswerte-Zeichen erscheinen, was der Benutzer bloß betätigen muss, damit die Rechnung vollständig ist. Diese Art der Gleichung ist wie man sieht von den anderen zu unterscheiden, da sie, falls bekannte Variablen eingesetzt wurden, lediglich aus anderen generiert wurde, also keine Information hinzufügt und damit nicht zum Einsetzen in weitere Berechnungen geeignet ist. Daher muss die Klasse \displaycode{Equation} über mehrere Unterklassen wie zum Beispiel \displaycode{UnfinishedEquation} oder \displaycode{DeductiveEquation} verfügen. Mehr zu diesem Thema im folgenden Textabschnitt.

\subsubsection{Einlesen mathematischer Strukturen}
Damit möchte ich zum nächsten großen Thema überschreiten, bei dem wir uns dem Einlesen oder \textit{Parsing} widmeten. Die größte Hürde scheint zu sein, dass auch halbfertige Rechnungen abbildbar sein sollten. So macht das grundsätzliche Parsing wenig Probleme, wenn auch ein wenig zusätzliche Struktur dahinter steckt, ganz im Gegensatz zur eben behandelten Darstellung.\\
\\
Die beste Möglichkeit, dies anzugehen war unserer Meinung nach, das tatsächliche Parsing auszulagern. Das hat, unter dem Vorwand, dass zu jeder Unterklasse von \displaycode{MathObject} von nun an auch eine Parser-Klasse besteht, den Vorteil, dass Parser-Klassen zentral in Arrays abgespeichert werden können. Das ist hier deshalb wichtig, weil Methoden, die Parsing betreiben wollen, anfangs nicht wissen können, worum es sich handelt. Die Formulierung des letzten Satzes lässt vielleicht folgende Frage zu: ''Warum erkennt das Programm nicht zuerst, worum es sich handelt und übersetzt anschließend?'' Doch das einzige Parsing, das hier an Java weitergegeben werden kann, ist das für Zahlen, dafür existieren vorgefertigte Methoden. Und selbst diese ''versuchen'' es zuerst und wenn es nicht gelingt, tritt eine Ausnahmesituation ein, die abgefangen werden muss. Die Phrasierung war an dieser Stelle bewusst gewählt, in Java werden nämlich die Schlüsselwörter \displaycode{try}, \displaycode{Exception} und \displaycode{catch} verwendet, wie später noch einige Bildschirmaufnahmen verdeutlichen sollen.\\
\\
Nun also zurück zur in den Raum gestellten Frage. Ein Parser ist in unserer Struktur die einzige Klasse, die Information darüber beinhaltet, wie ein Text in ein \displaycode{MathObject} übersetzt werden soll und das ist auch so vorgesehen. Nur so kann echte Kapselung garantiert werden. Und aus diesem Grund soll auch der Parser \underline{sowohl} feststellen, ob eine Übersetzung möglich ist \underline{als auch} übersetzen, wenn es ihm möglich ist. In diesem Fall haben wir uns also zu einem gewissen Grad an der Java-Denkweise orientiert.\\
\\
\displayimageg{img/sachsenschnitzel/code_ConstantParser_tryParse_cropped}{Die Parsing-Methode für \displaycode{Constant}}
\ \\
Damit bleibt allerdings immer noch das Problem mit den unvollständigen Eingaben bestehen. Im Endeffekt gibt der Benutzer Strings ein, dadurch, dass die Tastatur zum Bedienen des Programms genutzt wird. Diese Strings müssen übersetzt werden und könnten zum Beispiel folgendermaßen aussehen: ''1+2+'' wenn die Eingabe noch nicht vollständig ist oder gar ''1.5+3.1.2'' als Beispiel für fehlerhafte Eingabe bei einem Tippfehler. Beides muss die Erweiterung der Struktur abbilden können und trotzdem gut erkennen können wo genau der Fehler ist und wodurch er bedingt ist, um Fehlererkennung in weiteren Versionen der Software zu ermöglichen.\\
\\
Nach etlichen Überlegungen ergab sich für uns als wohl sinnvollste Lösung, eine Klasse einzuführen, die temporär wie ein Text funktioniert und die am Ende auch für das Parsing zuständig sein sollte. Anfangs sollte diese Funktionalität nur im Bereich \displaycode{Term} implementiert werden, um eine Art Miniatur-Prototyping durchzuführen. Die zuständige Klasse \displaycode{UnfinishedTerm} übernahm im Grunde alles vom \displaycode{com.frequem.epic.sprite.Text}, da sich die beiden Klassen ja sehr ähnlich waren, mit dem einzigen Unterschied, das \displaycode{UnfinishedTerm} von \displaycode{Term} erben sollte.\\
\\
Um das Parsing nun auch in das System zu integrieren, ohne zu viel von der aktuellen Struktur abändern zu müssen und gleichzeitig Flexibilität für zukünftige Versionen zu bewahren, kam folgendes neues Konzept zum Einsatz: Jede Unterklasse von \displaycode{Term} soll eine neue Methode \displaycode{void parseContent(int offset)} vererbt bekommen. Zum 'offset' möchte ich später noch kommen. Diese Methode ermöglicht es nun der Klasse \displaycode{UnfinishedTerm}, bis auf das tatsächliche Übersetzen alles in Hinblick auf Parsing zu übernehmen, wie man im folgenden Programmteil erkennen kann.\\
\\
\displayimageg{img/sachsenschnitzel/code_UnfinishedTerm_parseContent_cropped}{Parsing-Vorgang in \displaycode{UnfinishedTerm}}
\ \\
Der Parameter 'offset' ist deshalb wichtig, weil der Benutzer beispielsweise wahrscheinlich nicht wollen würde, dass seine Eingabe schon als erkannt abgestempelt wird, bevor er damit abgeschlossen hat. Aus diesem Grund gibt dieser Parameter an, wie viele Elemente (von rechts aus) noch nicht dem Parsing unterzogen werden sollen. Die Berücksichtigung dieses Parameters is logischerweise die Aufgabe der Klassen, an die es weitergegeben wird. Aus der Grafik kann man erkennen, dass ganz einfach alle Parser nach der Reihe ihr Glück versuchen. Wenn sie ihre Arbeit nicht erledigen können, weil der gegebene String nicht dem jeweiligen Objekt entspricht, wird der Wert \displaycode{null} zurückgegeben, was vom aufrufenden Programm interpretiert werden soll als ''Interpretation nicht möglich''. Wenn die Übersetzung allerdings gelingt, wird gerade dieser Term zurückgegeben und soll dann dessen Unterelemente übersetzen.\\
\\
An dieser Stelle war ein Workaround nötig, da es die Objektstruktur von Java nicht vorsieht, dass verwandte Objekte den Datentyp wechseln können. So könnte zum Beispiel eine \displaycode{Sum} eine \displaycode{Constant} erstellen, aber sich nicht selbst dadurch ersetzen. Im Falle eines \displaycode{UnfinishedTerm} wäre es jedoch notwendig, dass der vom Parsing resultierende \displaycode{Term} die Stelle des ursprünglichen \displaycode{UnfinishedTerm} einnimmt, da das ja der Grund für das Parsing ist.\\
\\
Unsere Lösung zu diesem Thema ist, die Methode \displaycode{void changeSubterm(Term o, Term n)} für jeden \displaycode{Term} einzuführen. Da jede Unterklasse von \displaycode{Term} nur selbst wissen kann wie und in welchen Variablen ihre möglichen Subterme gespeichert sind, kann die Methode leider nicht pauschal geschrieben werden. So könnte diese beispielsweise in der Klasse \displaycode{Sum} durch die Summanden iterieren und auf Übereinstimmung prüfen, bei \displaycode{Constant} hingegen einfach abschließen, da in dieser Klasse keine Subterme vorhanden sind.\\
\\
\displayimageg{img/sachsenschnitzel/code_Sum_changeSubterm_cropped}{Methode zum austauschen von Subtermen in \displaycode{Sum}}
\ \\
Das Einteilen der Parser in verschiedene Kategorien macht zusätzlich die Übersetzung von Klammer-Operationen und Ähnlichem möglich. Die erste Einteilung ist davon zwar noch fern, ist jedoch ebenfalls wichtig, um sicher zu stellen, dass Operationen nicht als Teil von Variablennamen interpretiert werden können. Das bringt den zusätzlichen Vorteil mit sich, dass in den frühen Softwareversionen keine \textit{Naming-Convention} für Variablen gibt, also keine unerlaubten Zeichen, außer was sich durch Operationen ergibt (''+'', ''-'', ...). Hier kann sogar behauptet werden, dass gar keine Naming-Conventions getroffen werden müssten, da Erweiterungsmodule ganz neue Operationszeichen mit sich bringen könnten, die diese damit überflüssig machen würden.\\
\\
Die dritte Parser-Kategorie, die soeben erwähnt wurde, tauften wir \displaycode{EncapsulatorParser} passend zu der \displaycode{Term}-Unterklasse \displaycode{Encapsulator}. Hier bestand der Hintergedanke grundsätzlich darin, dass \textit{Encapsulator}, das soll in etwa ''Einkapselung'' bedeuten, eine Position als Term haben, die sich grundsätzlich von allen anderen unterscheidet. Diese Terme sind trotz ausgefallenem Namen einfach dafür vorgesehen, Klammern und alles, was andere Terme auf diese Art einschließt, zu verkörpern (stellen also eine Mutterklasse für diese dar). Für eine klare Software-Struktur ist man natürlich daran interessiert, so viel wie möglich zusammen zu fassen und zu vereinfachen, weswegen wir uns eben für die Mutterklasse entschieden haben.\\
\\
Warum nun alle Klassen, die von \displaycode{Encapsulator} erben, eine besondere Position haben, wird dann klar, wenn man sich mit dem Parsing in Parser-Klassen auseinandersetzt (im Gegensatz zum Parsing in Term-Klassen). Zum Beispiel in \displaycode{SumParser} muss natürlich jedes einzelne Zeichen überprüft werden, ob es dem Operator ($+$) entspricht. Erst dann können die verbleibenden Zeichen dazwischen weiterverarbeitet werden. Sind im vorgegebenen String allerdings Klammern enthalten, so soll nicht alles berücksichtigt werden, sondern eben nur Dinge außerhalb von Klammern. Und genau nach diesem Konzept wurden die Klassen \displaycode{Encapsulator} und \displaycode{EncapsulatorParser} aufgezogen.\\
\\
Da alle Parser die Einkapselungen berücksichtigen müssen, zahlte es sich unserer Meinung nach aus, eine zentrale Methode zur Verfügung zu stellen. Mit dem Methodenkopf \displaycode{String[] separateBy(String data, char op)} ist sie nun für das zuständig, wie es ihr Name beschreibt. Sie kann von jeder Parser-Klasse verwendet werden und berücksichtigt alle Einkapselungen, sodass das nicht in jeder Klasse einzeln passieren muss. In den nächsten Grafiken sind Methodendefinition und beispielhafte Verwendung im \displaycode{SumParser} abgebildet.\\
\\
\displayimageg{img/sachsenschnitzel/code_Parser_separateBy_cropped}{Methode zum String Aufteilen, die \displaycode{Encapsulator} berücksichtigt}
\displayimageg{img/sachsenschnitzel/code_SumParser_tryParse_cropped}{Verwendung der Methode in der \displaycode{SumParser}-Klasse}
\ \\
Aber nun möchte natürlich auch das Thema Auswertung nicht unerwähnt bleiben. Im Grunde funktioniert die Eingabe von Gleichungen genau im gleichen Sinne wie bisher, mit dem einzigen Unterschied, dass es sich nicht um Terme handelt. Und diese Unterscheidung ist auch gut, denn jetzt haben uns die Klammer- und Einkapselungsalgorithmen nicht in die Ecke gespielt. Klammern, die von einer Seite der Gleichung auf die andere gehen, existieren nicht und damit müssen sie beim Parsing auch nicht berücksichtigt werden. Jede Gleichungsart erhält im Grunde ihren zugehörigen Parser und die Klasse \displaycode{UnfinishedEquation} fungiert als eine Art \displaycode{UnfinishedTerm} der Welt der Gleichungen.\\
\\
Hiermit waren alle Software-Mathematik-Features für frühe Versionen unseres Produkts abgedeckt. Was eindeutig dicht darauf folgen sollte sind Funktionen und Gleichungssysteme, für die die mathematischen Konzepte sowie programmiertechnische Algorithmik schon bereit liegen.